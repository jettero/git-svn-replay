#!/usr/bin/perl
# vi:tw=0:
# $Id: git_replay 156.3611.0Kd1r2yAYdDqchmy2eBcYFChl3w 2007-06-11 17:36:15 -0400 $

use strict;
use DBI;
use DBM::Deep;
use Term::GentooFunctions qw(:all);
use File::Find;

die "$0 gitrepo replaydb svnco" unless @ARGV == 3;

my $gitrepo = shift @ARGV;
my $dbfile  = shift @ARGV;
my $svnco   = shift @ARGV;

my $TOP = new DBM::Deep($dbfile); $TOP->{$svnco} = {} unless ref $TOP->{$svnco} eq "HASH";
my $dbm = $TOP->{$svnco};

&setup;
&run;

# setup {{{
sub setup {
    if( not -d "$svnco/.git/" ) {
        local $ENV{GIT_DIR} = "$svnco/.git";

        ebegin "cloning $gitrepo";
        system(qw(git clone --bare), $gitrepo, $ENV{GIT_DIR}) == 0 or die;
        system(qw(cg branch-add origin), $gitrepo) == 0 or die; # needs the GIT_DIR
        eend 1;
    }

    chdir $svnco or die "couldn't chdir into svnco($svnco): $!";
    ebegin "pulling updates from $gitrepo";
    system(qw(cg seek master)) == 0 or die;
    system(qw(cg reset)) == 0 or die;
    system(qw(cg update)) == 0 or die;
    eend 1;
}
# }}}
# run {{{
sub run {
    open my $in, "git rev-list --all --parents | tac |" or die "error with revlist popen(): $!";
    while(<$in>) {
        my ($commit, $parent) = split /\s+/;

        next if $dbm->{already_replayed}{$commit};

        if( &replay($commit, $parent) and &inform_svn($commit, $parent) ) {
            $dbm->{already_replayed}{$commit} = 1;

        } else {
            last;
        }
    }
    close $in;
}
# }}}

# replay {{{
sub replay {
    my ($commit, $parent) = @_;

    my $zero = sub {
        eerror $_[0];
        eend 0;
        return 0;
    };

    einfon "cg seek -- ";
    system(qw(cg seek), $commit) == 0 or return $zero->("seek $commit error");
    eend 1;

    ebegin "dumping commit log to .msg";
    system("git log -r $parent..$commit > .msg") == 0 or die;
    eend 1;

    return 1;
}
# }}}
# inform_svn {{{
sub inform_svn {
    my ($commit, $parent) = @_;

    my @files;
    my @dirs;

    &File::Find::find({wanted => sub {
        if( -f $_ ) {
            unless( $_ eq ".msg" ) {
                push @files, $File::Find::name;
            }

        } elsif( -d _ ) {
            if( m/^\.(?:git|svn)\z/ ) {
                $File::Find::prune = 1;

            } elsif( not m/^\.{1,2}\z/ ) {
                push @dirs, $File::Find::name;
            }
        }

    }}, '.' );

    if( $parent ) {
        for my $f (@{ $dbm->{last_files}{$parent} }) {
            unless( -f $f ) {
                einfon "removing file \"$f\" from svn:  ";
                system(qw(svn rm), $f) == 0 or die;
                eend 1;

                $dbm->{already_tracking_file}{$f} = 0;
            }
        }
        for my $d (@{ $dbm->{last_dirs}{$parent} }) {
            unless( -d $d ) {
                einfon "removing directory \"$d\" from svn:  ";
                system(qw(svn rm), $d) == 0 or die;
                eend 1;

                $dbm->{already_tracking_dir}{$d} = 0;
            }
        }
    }

    for my $d (@dirs) {
        next if $dbm->{already_tracking_dir}{$d};

        einfon "adding directory \"$d\" to svn:  ";
        system(qw(svn add), $d) == 0 or die;
        eend 1;

        $dbm->{already_tracking_dir}{$d} = 1;
    }

    for my $f (@files) {
        next if $dbm->{already_tracking_file}{$f};

        einfon "adding file \"$f\" to svn:  ";
        system(qw(svn add), $f) == 0 or die;
        eend 1;

        $dbm->{already_tracking_file}{$f} = 1;
    }

    ebegin "comitting changes to svn";
    system(qw(svn commit -F .msg)) == 0 or die;
    eend 1;

    $dbm->{last_dirs}{$commit}  = \@dirs;
    $dbm->{last_files}{$commit} = \@files;

    return 1;
}
# }}}
