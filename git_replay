#!/usr/bin/perl

use strict;
use DBM::Deep;
use File::Spec;
use File::Find;
use File::Slurp qw(write_file);
use Term::GentooFunctions qw(:all);
use IPC::System::Simple qw(systemx capturex);
use Tie::File;
use Date::Parse; # dates in (Date::Manip will not handle git/date-R time...)
use POSIX; # dates out
use Getopt::Std;
use Pod::Usage;
use Carp;

my %o; getopts("qd:b:l:", \%o) or pod2usage(); quiet() if $o{q};
pod2usage unless @ARGV == 2;

my $gitrepo   = shift;
my $srcbranch = $o{b} || "master";
my $svnco     = File::Spec->rel2abs( shift );
my $dbfile    = $o{d} || "./replay.rdb";
my $stdoutlog = $o{l};

my $TOP = new DBM::Deep($dbfile); $TOP->{$svnco} = {} unless $TOP->{$svnco};
my $dbm = $TOP->{$svnco};

setup();
run();

# setup {{{
sub setup {
    chdir $svnco or die "couldn't chdir into svnco($svnco): $!";

    if( not -d "$svnco/.git/" ) {
        ebegin "cloning $gitrepo ($srcbranch)";
        logging_systemx(qw(git init));
        logging_systemx(qw(git symbolic-ref HEAD refs/heads/mirror));
        eend 1;

    } else {
        ebegin "resettting mirror";
        logging_systemx(qw(git checkout -q mirror));
        logging_systemx(qw(git reset --hard));
        eend 1;

    }

    ebegin "pulling updates from $gitrepo ($srcbranch)";
    logging_systemx(qw(git pull), $gitrepo, "$srcbranch:mirror") == 0 or die;
    eend 1;
}
# }}}
# run {{{
sub run {
    my @commits = capturex(qw(git rev-list --reverse mirror));

    chomp @commits;

    for my $commit ( grep { !$dbm->{already_replayed}{$_} } @commits ) {
        $dbm->{already_replayed}{$commit} = 1
            if replay($commit) and inform_svn($commit);
    }
}
# }}}

# replay {{{
sub replay {
    my ($commit) = @_;

    einfo "REPLAY $commit";

    einfon "git checkout -- ";
    logging_systemx(qw(git checkout -q), $commit);
    eend 1;

    ebegin "dumping commit log to .msg";
    write_file(".msg" => capturex(qw(git show --stat=65)));
    eend 1;

    tie my @a, 'Tie::File', ".msg" or die "error tieing .msg: $!";
    if( @a and @a > 4) {
        ebegin "reversing commit detail location";
        my $max = 1500;
        push @a, "- :: $gitrepo commit info :: -------------------";
        while(1) {
            last if $a[0] =~ m/^\s*$/;

            push @a, shift @a;

            if( --$max < 0 ) {
                die "we seem to have hit an infinite loop... @a";
            }
        }
        eend 1;
    }
    untie @a;

    return 1;
}
# }}}
# inform_svn {{{
sub inform_svn {
    my ($commit, $parent) = @_;

    einfo "INFORM $commit";

    my @files;
    my @dirs;

    &File::Find::find({wanted => sub {
        if( -f $_ ) {
            unless( $_ eq ".msg" ) {
                push @files, $File::Find::name;
            }

        } elsif( -d _ ) {
            if( m/^\.(?:git|svn)\z/ ) {
                $File::Find::prune = 1;

            } elsif( not m/^\.{1,2}\z/ ) {
                push @dirs, $File::Find::name;
            }
        }

    }}, '.' );

    if( $parent ) {
        for my $f (@{ $dbm->{last_files}{$parent} }) {
            unless( -f $f ) {
                einfon "removing file \"$f\" from svn:  ";
                logging_systemx(qw(svn rm), $f);
                eend 1;

                $dbm->{already_tracking_file}{$f} = 0;
            }
        }
        for my $d (@{ $dbm->{last_dirs}{$parent} }) {
            unless( -d $d ) {
                einfon "removing directory \"$d\" from svn:  ";
                logging_systemx(qw(svn rm), $d);
                eend 1;

                $dbm->{already_tracking_dir}{$d} = 0;
            }
        }
    }

    for my $d (@dirs) {
        next if $dbm->{already_tracking_dir}{$d};

        einfon "adding directory \"$d\" to svn:  ";
        logging_systemx(qw(svn add), $d);
        eend 1;

        $dbm->{already_tracking_dir}{$d} = 1;
    }

    for my $f (@files) {
        next if $dbm->{already_tracking_file}{$f};

        einfon "adding file \"$f\" to svn:  ";
        logging_systemx(qw(svn add), $f);
        eend 1;

        $dbm->{already_tracking_file}{$f} = 1;
    }

    ebegin "comitting changes to svn";
    logging_systemx(qw(svn commit -F .msg));
    eend 1;

    my $date;
    my $mdate;
    open my $in, ".msg" or die "error opening commit message: $!";
    while(<$in>) {
        # Date:   Sat Mar 24 14:42:29 2007 -0400
        # 2007-06-11T23:38:06.463364Z
        if( m/^Date:\s+(\w{3}\s+\w{3}.+[+-]\d{4})\s*$/ ) {
            $mdate = $1;
            if( my $s = str2time($mdate) ) {
                $date = strftime('%Y-%m-%dT%H:%M:%S.000000Z', gmtime($s));
            }
            last;
        }
    }
    close $in;

    if( $date ) {
        ebegin "changing commit date to $date ($mdate)";
        logging_systemx(qw(svn propset --revprop -r HEAD svn:date), $date);
        eend 1;

    } else {
        ewarn "date not found for $commit";
    }

    $dbm->{last_dirs}{$commit}  = \@dirs;
    $dbm->{last_files}{$commit} = \@files;

    # svn commits sometimes alters things causing git merge problems (very rare).
    # This resets everything that's tracked by git.
    logging_systemx(qw(git reset --hard));

    return 1;
}
# }}}

# quiet {{{
sub nop { print @_, "\n" }
sub quiet {
    *eend = *nop;
    *einfo = *nop;
    *ebegin = *nop;
    *einfon = *nop;
    *ewarn = *nop;
}
# }}}
# stdoutlog {{{
sub stdoutlog {
    return unless $stdoutlog;

    write_file( $stdoutlog, {append=>1}, scalar localtime, @_ );
}
# }}}
# logging_systemx {{{
sub logging_systemx {
    my @res = eval { (capturex(@_), "my res pop") };
    croak $@ unless pop @res;
    stdoutlog("-- execvp(@_)\n", @res);
}
# }}}

__END__

=head1 NAME

git_replay - replay git commits into an svn repo

=head1 SYNOPSIS

  git_replay [options] repo.git checkout_out.svn
    -q: quiet operations
    -b: branch to pull (default: master)
    -d: database location (default: ./replay.rdb)
    -l: stdout logfile (default: /dev/null)

=head1 OPTIONS

=over

=item B<-q>

Shhhhh

=item B

=back B<-b>

The name of the branch to pull (defaults to master).

=back B<-d>

The location of the database file (defaults to: ./replay.rdb).

=back B<-l>

Git and SVN make a lot of racket.  By default the racket is ignored, but you
may choose to dump the racket to a file if you wish.

=head1 DESCRIPTION

=head2 B<repo.git>

The source repo will be untouched, can be remote or local, all git urls will work just fine.

=head2 B<replay.db>

The location of the L<DBM::Deep> commit database.  Warning, this database keeps
track of which commits have already been replayed. You'll end up with dups and
conflicts if this gets corrupted... then you'll have to rebuild.  Blulech.

=head1 AUTHOR

Paul Miller C<< <jettero@cpan.org> >>

=head2 COPYRIGHT

Copyright 2009 Paul Miller -- released under the GPL

=head2 SEE ALSO

perl(1), git(1), svn(1), L<DBM::Deep>, L<IPC::System::Simple>
