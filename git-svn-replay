#!/usr/bin/perl

use strict;
use warnings;

use Carp;
use DBM::Deep;
use File::Spec;
use File::Find;
use File::Slurp qw(write_file slurp);
use Term::GentooFunctions qw(:all);
use IPC::System::Simple qw(systemx capturex);
use Date::Parse; # dates in (Date::Manip will not handle git/date-R time...)
use POSIX; # dates out
use Getopt::Long;
use Pod::Usage;

our $VERSION = 1.0;

my $srcbranch   = "master";
my $dbfile      = "replay.rdb";
my $patchformat = '%s [%h]%n%n%b%n%aN <%aE>%n%ai%n%H';
my $stdoutlog;

my ($svnco, $gitrepo) = process_options();

my $TOP = new DBM::Deep($dbfile); $TOP->{$svnco} = {} unless $TOP->{$svnco};
my $dbm = $TOP->{$svnco};

my $progress; # cheap way to propagate completeness info to all info messages

setup();
run();

# setup {{{
sub setup {
    chdir $svnco or die "couldn't chdir into svnco($svnco): $!";

    if( not -d "$svnco/.git/" ) {
        ebegin "cloning $gitrepo ($srcbranch)";
        logging_systemx(qw(git init));
        logging_systemx(qw(git symbolic-ref HEAD refs/heads/mirror));
        eend 1;

    } else {
        ebegin "resettting mirror";
        logging_systemx(qw(git checkout -q mirror));
        logging_systemx(qw(git reset --hard));
        eend 1;

    }

    ebegin "pulling updates from $gitrepo ($srcbranch)";
    logging_systemx(qw(git pull), $gitrepo, "$srcbranch:mirror");
    eend 1;
}
# }}}
# run {{{
sub run {
    my @commits = capturex(qw(git rev-list --reverse mirror)); chomp @commits;
       @commits = grep { !$dbm->{already_replayed}{$_} } @commits;

    my $total = @commits;
    my $cur = 1;

    for my $commit ( @commits ) {
        $progress = "[$cur/$total]:$commit";

        if( replay($commit) and inform_svn($commit) ) {
            push @{ $dbm->{replayed_commits_in_order} }, $commit;
            $dbm->{already_replayed}{$commit} = 1

        } else {
            edie("no point in continuing, something is wrong");
        }

        $cur ++;
    }
}
# }}}

# replay {{{
sub replay {
    my ($commit) = @_;

    einfo "REPLAY $progress";
    eindent;

    einfo "git checkout";
    logging_systemx(qw(git checkout -q), $commit);
    eend 1;

    ebegin "dumping commit log to .msg";    # subject [hash]\n\n body \n author <email>\n full-hash
    write_file(".msg" => capturex(qw(git show -s), '--pretty=format:' . $patchformat));
    eend 1;

    eoutdent;
    return 1;
}
# }}}
# inform_svn {{{
sub inform_svn {
    my ($commit) = @_;

    einfo "INFORM $progress";
    eindent;

    my @files;
    my @dirs;

    &File::Find::find({wanted => sub {
        if( -f $_ ) {
            unless( $_ eq ".msg" ) {
                push @files, $File::Find::name;
            }

        } elsif( -d _ ) {
            if( m/^\.(?:git|svn)\z/ ) {
                $File::Find::prune = 1;

            } elsif( not m/^\.{1,2}\z/ ) {
                push @dirs, $File::Find::name;
            }
        }

    }}, '.' );

    if( my $parent = $dbm->{replayed_commits_in_order}[-1] ) {
        for my $f (@{ $dbm->{last_files}{$parent} }) {
            unless( -f $f ) {
                einfo "removing file \"$f\" from svn:  ";
                logging_systemx(qw(svn rm), $f);
                eend 1;

                $dbm->{already_tracking_file}{$f} = 0;
            }
        }
        for my $d (@{ $dbm->{last_dirs}{$parent} }) {
            unless( -d $d ) {
                einfo "removing directory \"$d\" from svn:  ";
                logging_systemx(qw(svn rm), $d);
                eend 1;

                $dbm->{already_tracking_dir}{$d} = 0;
            }
        }
    }

    for my $d (@dirs) {
        next if $dbm->{already_tracking_dir}{$d};

        einfo "adding directory \"$d\" to svn:  ";
        logging_systemx(qw(svn add), $d);
        eend 1;

        $dbm->{already_tracking_dir}{$d} = 1;
    }

    for my $f (@files) {
        next if $dbm->{already_tracking_file}{$f};

        einfo "adding file \"$f\" to svn:  ";
        logging_systemx(qw(svn add), $f);
        eend 1;

        $dbm->{already_tracking_file}{$f} = 1;
    }

    ebegin "comitting changes to svn";
    logging_systemx(qw(svn commit -F .msg));
    eend 1;

    if( my $gdate = capturex(qw(git show -s --pretty=format:%at)) ) {
        my $date = strftime('%Y-%m-%dT%H:%M:%S.000000Z', gmtime($gdate));

        ebegin "changing commit date to $date";
        logging_systemx(qw(svn propset --revprop -r HEAD svn:date), $date);
        eend 1;

    } else {
        ewarn "date not found for $commit";
    }

    $dbm->{last_dirs}{$commit}  = \@dirs;
    $dbm->{last_files}{$commit} = \@files;

    # svn commits sometimes alters things causing git merge problems (very rare).
    # This resets everything that's tracked by git.
    logging_systemx(qw(git reset --hard));

    eoutdent;
    return 1;
}
# }}}

# quiet {{{
sub nop { print @_, "\n" }
sub quiet {
    *eend = *nop;
    *einfo = *nop;
    *ebegin = *nop;
    *ewarn = *nop;
}
# }}}
# stdoutlog {{{
sub stdoutlog {
    return unless $stdoutlog;

    write_file( $stdoutlog, {append=>1}, scalar localtime, @_ );
}
# }}}
# logging_systemx {{{
sub logging_systemx {
    my @res = eval { (capturex(@_), "my res pop") };
    croak $@ unless pop @res;
    stdoutlog("-- execvp(@_)\n", @res);
}
# }}}

# process_options {{{
sub process_options {
    my %o = ( 'q'=>\&quiet, 'h'=>sub{pod2usage(-verbose=>1)},
        'b=s'=>\$srcbranch, 'd=s'=>\$dbfile, 'l=s'=>\$stdoutlog, 'f=s'=>\$patchformat,
    );

    GetOptions(%o) or pod2usage();
    pod2usage unless @ARGV == 2;

    my $g = shift @ARGV;
    my $s = File::Spec->rel2abs( shift @ARGV );

    return ($s, $g);
}
# }}}

__END__

=head1 NAME

git-svn-replay - replay git commits into a throwaway svn repo

=head1 SYNOPSIS

  git-svn-replay [options] repo.git checked_out.svn
              or -S ... check_out.svn
              or -s ... checked_out.svn

    -q: quiet operations
    -b: branch to pull (default: master)
    -d: database location (default: ./replay.rdb)
    -l: stdout logfile (default: /dev/null)
    -f: .msg format
    -S: create an svn repo and check it out
    -s: directory to add to the svn repo
    -h: help

B<repo.git>: The source repo will be untouched, can be remote or local, all git
urls will work just fine.

B<replay.db>: The location of the L<DBM::Deep> commit database.

B<checked_out.svn>: This will issue svn commands to the checked_out.svn (and
the corresponding repo).  It is assumed this is a throwaway repo used for
nothing besides interacting with trac.

=head1 DESCRIPTION

This tool simply replays a git repo into an svn repo for the purpose of using
svn natively in Trac.  It has the side effect of helping to import more than one
project into Trac -- something it did not yet support at the time of this
writing.

The svn repo that this tool creates and uses is assumed to be a throwaway and is
not meant for people to pull from or push to.  It will most likely get dropped
and recreated from scratch more than once (from bugs in this app or other
problems).  This means that the revision numbers will be almost useless and
patches may not align quite right.

This tool is really I<only> useful for viewing commits in Trac.  It probably has
no other purpose.

=head1 OPTIONS

=over

=item B<-q>

Shhhhh

=item B<-b> branchname

The name of the branch to pull (defaults to master).

=item B<-d> dbname

The location of the database file (defaults to: ./replay.rdb).

=item B<-l> logfilename

Git and SVN make a lot of racket.  By default the racket is ignored, but you
may choose to dump the racket to a file if you wish.

=item B<-f> formatstring

The git pretty=format: argument describing the .msg used in svn.  By default,
it's:

   %s [%h]%n%n%b%n%aN <%aE>%n%ai%n%H

... which looks like this:

    git commit subject

    git commit message body git commit message body
    git commit message body

    Paul Miller <jettero@cpan.org>
    ddc7db5df1261cfef79b8bfce524a7b7452ac95d.

=back

=item B<-S> svnreponame

Create an svn repo and check it out.  It is harmless to specify this if the
repo already exists -- it will simply skip the creation.

When B<-S> is specified, you may not specify a git repo to pull from, but you
must specify a location to check out the new svn.

=item B<-s> subdirname

Add a subdirectory to the checked out svn.

When B<-s> is specified, you may not specify a git repo to pull from, but you
must specify a location where the svn subdir should be added.

=head1 EXAMPLES

Create an svn repo, check it out, and add a few subdirs to it:

    git svn-replay -S s.repo -s blarg1 -s blarg2 -s blarg3 s.co

Add another dir later:

    git svn-replay -s blarg4 s.co

Create an svn repo, check it out, and pull the public branch of repo.git into it:

    git svn-replay -S s.repo s.co
    git svn-replay -b public repo.git s.co # repeat this every day or hour

Create an svn repo, check it out, create a dir for proj1, another for proj2 ...:

    git svn-replay -S s.repo -s proj1 -s proj2 s.co 
    git svn-replay -b public proj1-repo.git s.co/proj1 # do this from cron
    git svn-replay -b maint  proj2-repo.git s.co/proj2 # do this from cron

=head1 DISCLAIMER

It's maybe 100% certain that there's bugs in this strange thing.

Please make backups of all your svn and git repositories before you try to use
this for anything.  Also, please do not blame me if it ruins your repos.  I
warned you to make backups.

Do not attempt to use the generated svn repo as a code repository.

=head1 REPORTING BUGS

You can report bugs either via rt.cpan.org or via the issue tracking system on
github.  I'm likely to notice either fairly quickly.

=head1 AUTHOR

Paul Miller C<< <jettero@cpan.org> >>

=head2 COPYRIGHT

Copyright 2009 Paul Miller -- released under the GPL

=head2 SEE ALSO

perl(1), git(1), svn(1), L<DBM::Deep>, L<IPC::System::Simple>
